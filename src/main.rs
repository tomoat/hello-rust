// mod factorial;
// mod issues;
// mod threads;

fn main() {
    // println!("Hello, world!");
    greet_world();
    println!("===========================");
    test();
    println!("===========================");
    penguin();
    println!("===========================");
    add_one();
    println!("===========================");
    adds();
    println!("===========================");
    // add_one_to_number();
    mutable();
    println!("===========================");
    basic_type();
    println!("===========================");
    complex_num();
    println!("===========================");
    char();
    println!("===========================");
    expression_fuc();
    println!("===========================");
    renference_and_dereference();
    println!("===========================");
    // println!("{}", factorial::factorial(5));
    // println!("{}", issues::issues());
    // println!("{}", threads::threads());
    compound_types();
    println!("===========================");
}

fn greet_world() {
    let southern_germany = "GrÃ¼ÃŸ Gott! ğŸ˜Š";
    let chinese = "ä¸–ç•Œï¼Œä½ å¥½ ğŸ˜Š";
    let english = "World, Hello ğŸ˜Š";
    let regions = [southern_germany, chinese, english];

    for regions in regions.iter() {
        println!("{}", regions)
        // println!("{}", &regions)
    }
}

// Rust åŸç”Ÿæ”¯æŒ UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²
// println åé¢çš„ !, åœ¨ Rust ä¸­ï¼Œè¿™æ˜¯ å® æ“ä½œç¬¦ï¼Œä½ ç›®å‰å¯ä»¥è®¤ä¸ºå®æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹å‡½æ•°
// println æ²¡æœ‰ä½¿ç”¨ %s,%d æ¥åšè¾“å‡ºå ä½ç¬¦ï¼Œè€Œæ˜¯ä½¿ç”¨ {},å› ä¸º Rust ä¼šè‡ªåŠ¨è¯†åˆ«è¾“å‡ºæ•°æ®çš„ç±»å‹
// Rust çš„é›†åˆç±»å‹ä¸èƒ½ç›´æ¥è¿›è¡Œå¾ªç¯ï¼Œéœ€è¦å˜æˆè¿­ä»£å™¨(è¿™é‡Œæ˜¯é€šè¿‡ .iter() æ–¹æ³•)ï¼Œæ‰èƒ½ç”¨äºè¿­ä»£å¾ªç¯
// åœ¨ 2021 edition åŠä»¥å, æ”¯æŒç›´æ¥å†™ for region in regionsï¼ŒåŸå› æ˜¯å› ä¸º for éšå¼åœ°å°† regions è½¬æ¢æˆè¿­ä»£å™¨

fn penguin() {
    let penguin_data = "\
    common name,lengthï¼ˆcm)
    little penguin,33
    Yellow-eyed penguin,65
    Fiord-land penguin,60
    invalid,data
    ";
    let records = penguin_data.lines();
    for (i, record) in records.enumerate() {
        if i == 0 || record.trim().len() == 0 {
            continue;
        }

        // å£°æ˜ä¸€ä¸ªfieldså˜é‡ï¼Œç±»å‹æ˜¯Vec
        // Vecæ˜¯vectorçš„ç¼©å†™ï¼Œæ˜¯ä¸€ä¸ªå¯ä¼¸ç¼©çš„é›†åˆç±»å‹ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªåŠ¨æ€æ•°ç»„
        // <_>è¡¨ç¤ºVecä¸­çš„å…ƒç´ ç±»å‹ç”±ç¼–è¯‘å™¨è‡ªè¡Œæ¨æ–­ï¼Œåœ¨å¾ˆå¤šåœºæ™¯ä¸‹ï¼Œéƒ½ä¼šå¸®æˆ‘ä»¬çœå´ä¸å°‘åŠŸå¤«
        let fields: Vec<_> = record.split(',').map(|field| field.trim()).collect();
        if cfg!(debug_assertions) {
            // è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯è¾“å‡º
            eprintln!("debug: {:?} -> {:?}", record, fields);
        }

        let name = fields[0];
        // 1. å°è¯•æŠŠfields[1]çš„å€¼è½¬æ¢ä¸ºf32ç±»å‹çš„æµ®ç‚¹æ•°ï¼Œå¦‚æœæˆåŠŸï¼Œåˆ™æŠŠf32å€¼èµ‹ç»™lengthå˜é‡
        // 2. if letæ˜¯ä¸€ä¸ªåŒ¹é…è¡¨è¾¾å¼ï¼Œç”¨æ¥ä»=å³è¾¹çš„ç»“æœä¸­ï¼ŒåŒ¹é…å‡ºlengthçš„å€¼:
        // å½“=å³è¾¹çš„è¡¨è¾¾å¼æ‰§è¡ŒæˆåŠŸï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªOk(f32)çš„ç±»å‹ï¼Œè‹¥å¤±è´¥ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªErr(e)ç±»å‹ï¼Œif letçš„ä½œç”¨å°±æ˜¯ä»…åŒ¹é…Okä¹Ÿå°±æ˜¯æˆåŠŸçš„æƒ…
        // å†µ,å¦‚æœæ˜¯é”™è¯¯ï¼Œå°±ç›´æ¥å¿½ç•¥ï¼ŒåŒæ—¶if letè¿˜ä¼šåšä¸€æ¬¡è§£æ„åŒ¹é…ï¼Œé€šè¿‡Ok(length)å»åŒ¹é…å³è¾¹çš„Ok(f32)ï¼Œæœ€ç»ˆæŠŠç›¸åº”çš„f32å€¼èµ‹ç»™length
        // 3. å½“ç„¶ä½ ä¹Ÿå¯ä»¥å¿½è§†æˆåŠŸçš„æƒ…å†µï¼Œç”¨if let Err(e) = fields[1].parse::<f32>() {...}åŒ¹é…å‡ºé”™è¯¯ï¼Œç„¶åæ‰“å°å‡ºæ¥ï¼Œä½†æ˜¯æ²¡å•¥åµç”¨
        if let Ok(length) = fields[1].parse::<f32>() {
            // è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡º
            println!("{}, {}cm", name, length);
        }
    }
}

fn add_one() {
    let x = 5;
    let y = 10;
    let sum = x + y;
    println!("The sum of {} and {} is {}", x, y, sum);
}

// åœ¨ Rust ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ if let è¯­å¥æ¥åŒ¹é…å‡ºé”™è¯¯ï¼Œå¦‚æœåŒ¹é…æˆåŠŸï¼Œåˆ™æŠŠé”™è¯¯èµ‹ç»™å˜é‡ eï¼Œç„¶åæ‰“å°å‡ºæ¥
// Rust ç¨‹åºå…¥å£å‡½æ•°å¿…é¡»æ˜¯ fn main()ï¼Œè¿™æ ·æ‰èƒ½è¢«ç¼–è¯‘å™¨è¯†åˆ«ä¸ºä¸»å‡½æ•°ï¼Œè¯¥å‡½æ•°ç›®å‰æ— è¿”å›å€¼ï¼Œä¹Ÿæ— å‚æ•°
// ç”¨letæ¥å£°æ˜å˜é‡ï¼Œå˜é‡çš„ç±»å‹ç”±ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ let a = 10ï¼Œä¹Ÿå¯ä»¥ä¸»åŠ¨æŒ‡å®šç±»å‹ let b: i32 = 20ï¼Œå¦‚æœå˜é‡çš„ç±»å‹æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ { } æ¥è§£æ„
// å¯ä»¥åœ¨æ•°å€¼ä¸­å¸¦ä¸Šç±»å‹:30i32è¡¨ç¤ºæ•°å€¼æ˜¯30ï¼Œç±»å‹æ˜¯i32
// let mut c = 30i32 è¡¨ç¤ºcæ˜¯ä¸€ä¸ªå¯å˜çš„æ•´æ•°ï¼Œç±»å‹æ˜¯i32, mutæ˜¯mutableçš„ç¼©å†™è¡¨ç¤ºå¯å˜çš„
// let d = 30_i32 è¿˜èƒ½åœ¨æ•°å€¼å’Œç±»å‹ä¸­é—´æ·»åŠ ä¸€ä¸ªä¸‹åˆ’çº¿ï¼Œè®©å¯è¯»æ€§æ›´å¥½ï¼Œä½†æ˜¯ä¸èƒ½è¢«ç¼–è¯‘å™¨è¯†åˆ«ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨æ•°å€¼ä¸­ä½¿ç”¨ä¸‹åˆ’çº¿ï¼Œä½†æ˜¯å¯ä»¥åœ¨ç±»å‹ä¸­ä½¿ç”¨ä¸‹åˆ’çº¿
// å¯ä»¥ä½¿ç”¨å‡½æ•°è¿”å›å€¼æ¥æ¥æ”¶å‡½æ•°çš„è¿”å›å€¼ï¼Œå¦‚æœå‡½æ•°è¿”å›å€¼æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ { } æ¥è§£æ„
// å¯ä»¥ä½¿ç”¨å‡½æ•°è¿”å›å€¼æ¥ä½œä¸ºå‡½æ•°çš„å‚æ•°ï¼Œå¦‚æœå‡½æ•°è¿”å›å€¼æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ { } æ¥è§£æ„
// println! æ˜¯ä¸€ä¸ªå®ï¼Œå®ƒçš„ä½œç”¨æ˜¯è¾“å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒçš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè¡¨è¾¾å¼çš„å€¼ä¼šè¢«è¾“å‡ºåˆ°å­—ç¬¦ä¸²ä¸­ï¼Œ å®ƒçœ‹èµ·æ¥åƒæ˜¯å‡½æ•°ä½†æ˜¯å®ƒè¿”å›çš„æ˜¯å®å®šä¹‰çš„ä»£ç å—
// å®å®šä¹‰çš„ä»£ç å—å¯ä»¥åŒ…å«å¤šè¡Œä»£ç ï¼Œå®ƒä»¬ä¼šè¢«ç¼–è¯‘å™¨å¿½ç•¥ï¼Œå®ƒä»¬åªæ˜¯ä¸ºäº†æé«˜ç¼–è¯‘å™¨çš„æ€§èƒ½ï¼Œå®ƒä»¬ä¸ä¼šè¢«ç¼–è¯‘å™¨è§£æ
// { } æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼æˆ–å ä½ç¬¦ï¼Œå®ƒçš„å€¼æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼Œå®ƒçš„ç±»å‹æ˜¯è¡¨è¾¾å¼çš„ç±»å‹
// å­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å· "" è€Œä¸æ˜¯å•å¼•å· ''ï¼ŒRust ä¸­å•å¼•å·æ˜¯ç•™ç»™å•ä¸ªå­—ç¬¦ç±»å‹ï¼ˆcharï¼‰ä½¿ç”¨çš„
// Rust ä½¿ç”¨ {} æ¥ä½œä¸ºæ ¼å¼åŒ–è¾“å‡ºå ä½ç¬¦ï¼Œå…¶å®ƒè¯­è¨€å¯èƒ½ä½¿ç”¨çš„æ˜¯ %sï¼Œ%dï¼Œ%p ç­‰ï¼Œç”±äº println! ä¼šè‡ªåŠ¨æ¨å¯¼å‡ºå…·ä½“çš„ç±»å‹, å› æ­¤æ— éœ€æ‰‹åŠ¨æŒ‡å®š

fn adds() {
    let a = 10;
    let b: i32 = 20;
    // é€šè¿‡æ·»åŠ åˆ°å®ç”Ÿæˆçš„ä»£ç æ¥æŠ‘åˆ¶è­¦å‘Šï¼š
    #[allow(unused_mut)]
    let mut c = 30i32;
    let d = 30_i32;
    let e = add(add(a, b), add(c, d));
    println!("(a+b)+(c+d) = {}", e);
}

fn add(i: i32, j: i32) -> i32 {
    // è¿”å›ç›¸åŠ å€¼ï¼Œè¿™é‡Œå¯ä»¥å¿½ç•¥returnï¼Œä¸è¦æ·»åŠ ï¼›å·
    i + j
}

fn mutable() {
    // å¯å˜å˜é‡ï¼Œå€¼å¯ä»¥åœ¨å‡½æ•°ä¸­æ”¹å˜ï¼Œä½†æ˜¯ç±»å‹ä¸èƒ½æ”¹å˜
    let mut a = 10;
    println!("a = {}", a);
    a = 20;
    println!("a = {}", a);

    // å˜é‡é®è”½(shadowing)
    let b = String::from("hello");
    println!("b = {}", b);
    let (a, mut b): (bool, bool) = (true, false);
    // a = true,ä¸å¯å˜; b = falseï¼Œå¯å˜
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);

    // Rust å¸¸é‡çš„å‘½åçº¦å®šæ˜¯å…¨éƒ¨å­—æ¯éƒ½ä½¿ç”¨å¤§å†™ï¼Œå¹¶ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”å•è¯ï¼Œå¦å¤–å¯¹æ•°å­—å­—é¢é‡å¯æ’å…¥ä¸‹åˆ’çº¿ä»¥æé«˜å¯è¯»æ€§
    const MAX_POINTS: u32 = 100_000;
    println!("MAX_POINTS = {}", MAX_POINTS);

    let x = 5;
    // åœ¨å‡½æ•°çš„ä½œç”¨åŸŸå†…å¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
    // åœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡
    let x = x + 1;
    {
        // åœ¨å½“å‰çš„èŠ±æ‹¬å·ä½œç”¨åŸŸå†…ï¼Œå¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }
    // println!("x = {}", x);
    println!("The value of x is: {}", x);

    // å­—ç¬¦ä¸²ç±»å‹
    let spaces = "   ";
    // usizeæ•°å€¼ç±»å‹
    let spaces = spaces.len();
    println!("spaces = {}", spaces);
    // let mut spaces = "   ";
    // spaces = spaces.len();
    // å‰åspacesçš„ç±»å‹æ˜¯ä¸åŒçš„ï¼Œä¼šæŠ¥é”™

    // å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ
    // å‰åä¸¤ä¸ªå˜é‡çš„ç”Ÿå‘½å‘¨æœŸä¸ä¸€è‡´ï¼Œä¼šæŠ¥é”™ï¼Œ rustå¯¹ç±»å‹è¦æ±‚ä¸¥æ ¼
    // quote! å®ï¼Œç”¨äºç”Ÿæˆå­—ç¬¦ä¸²
}

fn basic_type() {
    // åŸºæœ¬ç±»å‹å’Œå¤åˆç±»å‹
    // æ•°å€¼ç±»å‹: æœ‰ç¬¦å·æ•´æ•°integer (i8, i16, i32, i64, isize)ã€ æ— ç¬¦å·æ•´æ•°unsigned (u8, u16, u32, u64, usize) ã€æµ®ç‚¹æ•° (f32, f64)ã€ä»¥åŠæœ‰ç†æ•°ã€å¤æ•°
    // å­—ç¬¦ä¸²ï¼šå­—ç¬¦ä¸²å­—é¢é‡å’Œå­—ç¬¦ä¸²åˆ‡ç‰‡ &str
    // å¸ƒå°”ç±»å‹ï¼š trueå’Œfalse
    // å­—ç¬¦ç±»å‹: è¡¨ç¤ºå•ä¸ªUnicodeå­—ç¬¦ï¼Œå­˜å‚¨ä¸º4ä¸ªå­—èŠ‚
    // å•å…ƒç±»å‹: å³ () ï¼Œå…¶å”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ ()

    // æ•°ç»„ï¼šæ•°ç»„æ˜¯ä¸€ç§æœ‰åºçš„é›†åˆï¼Œå…¶ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹çš„
    // å…ƒç»„ï¼šå…ƒç»„æ˜¯ä¸€ç§æœ‰åºçš„é›†åˆï¼Œå…¶ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹çš„
    // æšä¸¾ï¼šæšä¸¾æ˜¯ä¸€ç§æ„é€ çš„ç±»å‹ï¼Œå…¶ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹çš„
    // æ³¨æ„ï¼šæšä¸¾å’Œå…ƒç»„çš„åŒºåˆ«åœ¨äºï¼Œæšä¸¾æ˜¯æ„é€ çš„ç±»å‹ï¼Œå…ƒç»„æ˜¯å€¼ç±»å‹
    // å…ƒç»„çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹çš„ï¼Œæšä¸¾çš„å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒç±»å‹çš„

    // åŸºæœ¬æ•°æ®ç±»å‹ï¼šboolï¼Œcharï¼Œi8ï¼Œu8ï¼Œi16ï¼Œu16ï¼Œi32ï¼Œu32ï¼Œi64ï¼Œu64ï¼Œi128ï¼Œu128ï¼Œisizeï¼Œusizeï¼Œf32ï¼Œf64
    // åŸºæœ¬æ•°æ®ç±»å‹çš„é»˜è®¤å€¼æ˜¯0ï¼Œboolé»˜è®¤å€¼æ˜¯false
    let a = 10;
    let b = true;
    let c = 'c';
    let d = "hello";
    let e = [1, 2, 3];
    let f = vec![1, 2, 3];
    let g = d.len() as i32;
    let h = d.len();
    println!(
        "a = {}, b = {}, c = {}, d = {}, e = {:?}, f = {:?}, g = {:?}, h = {:?}",
        a, b, c, d, e, f, g, h
    );

    let guess: u32 = "42".parse().expect("Not a number!");
    // let guess = "42".parse::<u32>().expect("Not a number!");
    println!("guess = {}", guess);

    // f32 ç±»å‹æ˜¯å•ç²¾åº¦æµ®ç‚¹å‹ï¼Œf64 ä¸ºåŒç²¾åº¦æµ®ç‚¹å‹
    let m = 2.2;
    let n: f32 = 3.3;
    println!("m = {}, n = {}", m, n);

    let sum = m + m;
    let difference = 96.2 - 4.3;
    let product = 2 * 3;
    let quotient = 56.7 / 32.2;
    let remainder = 43 % 5;

    println!(
        "sum = {}, difference = {:.2}, product = {}, quotient = {}, remainder = {}",
        sum, difference, product, quotient, remainder
    );

    // assert!(0.1 + 0.2 == 0.3);
    // assert!((0.1 + 0.2 - 0.3) < 0.1);
    println!("{}", 0.1 + 0.2 == 0.3); // false
    println!("{}", (0.1 + 0.2 - 0.3) < 0.1); // true
    println!("{}", (0.1 + 0.2 - 0.3) < 0.2); // false
    println!("{}", (0.1 + 0.2 - 0.3)); // 0.00000000000000005551115123125783
    println!("{}", 0.1 + 0.2); // 0.30000000000000004
    println!("{}", (0.1 + 0.2 - 0.3) < 0.00001); // true
    println!("{}", (0.1 + 0.2 - 0.3) < 0.00002); // false
    println!("{}", (0.1_f64 + 0.2 - 0.3).abs() < 0.00001); //true

    // ======================
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("{:?}", abc);
    println!("{:?}", xyz);
    println!("{:?}", abc.0);
    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 != xyz.2);

    println!("{}", -42.0_f64.sqrt());
    println!("{}", -42.0_f32.sqrt());
    println!("{}", (-42.0_f32).sqrt());
    let _x = (-42.0_f32).sqrt();
    // assert_eq!(_x, _x) // NaNä¸èƒ½ç”¨æ¥æ¯”è¾ƒ
    // å‡ºäºé˜²å¾¡æ€§ç¼–ç¨‹çš„è€ƒè™‘ï¼Œå¯ä»¥ä½¿ç”¨ is_nan() ç­‰æ–¹æ³•ï¼Œå¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ•°å€¼æ˜¯å¦æ˜¯ NaN ï¼š
    if _x.is_nan() {
        println!("æœªå®šä¹‰çš„æ•°å­¦è¡Œä¸º{}", "NaN");
    }
    // assert!(!_x.is_nan()); // å¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ•°å€¼æ˜¯å¦æ˜¯ NaN ï¼š
    // assert!(!_x.is_infinite()); // æ— ç©·å¤§
    // assert!(!_x.is_finite()); // æœ‰é™çš„ï¼Œåªæœ‰ NaN æˆ–è€… Infinity æ‰æ˜¯æ— ç©·å¤§çš„
    // assert!(!_x.is_normal()); // æ­£å¸¸æ•°
    // assert!(_x.is_sign_positive()); // æ­£æ•°
    // assert!(_x.is_sign_negative()); // è´Ÿæ•°

    // Range(åºåˆ—)
    // åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼ŒåŸå› æ˜¯ï¼šå®ƒä»¬å¯ä»¥è¿ç»­çš„, åŒæ—¶ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸå¯ä»¥æ£€æŸ¥è¯¥åºåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå­—ç¬¦å’Œæ•°å­—å€¼æ˜¯ Rust ä¸­ä»…æœ‰çš„å¯ä»¥ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºç©ºçš„ç±»å‹
    println!("{:?}", 1..5); // 1..5 ç”Ÿæˆä» 1 åˆ° 4 çš„è¿ç»­æ•°å­—åºåˆ—
    println!("{:?}", 1..=5); // 1..=5 ç”Ÿæˆä» 1 åˆ° 5 çš„è¿ç»­æ•°å­—åºåˆ—
    for i in 1..=5 {
        println!("{}", i);
    }
    for i in 'a'..'f' {
        println!("{}", i);
    }
    // æœ‰ç†æ•°å’Œå¤æ•°
    // ä»»æ„å¤§å°çš„æ•´æ•°å’Œä»»æ„ç²¾åº¦çš„æµ®ç‚¹æ•°
    // å›ºå®šç²¾åº¦çš„åè¿›åˆ¶å°æ•°ï¼Œå¸¸ç”¨äºè´§å¸ç›¸å…³çš„åœºæ™¯
    // å®æ•°å’Œå¤æ•°
    // å®æ•°å’Œå¤æ•°æ˜¯ Rust ä¸­çš„ä¸¤ä¸ªåŸºæœ¬ç±»å‹ï¼Œå®ƒä»¬éƒ½æ˜¯æµ®ç‚¹æ•°ï¼Œä½†æ˜¯å®ƒä»¬çš„ç²¾åº¦ä¸åŒï¼Œå®æ•°æ˜¯æœ‰ç¬¦å·çš„ï¼Œè€Œå¤æ•°æ˜¯æ— ç¬¦å·çš„ã€‚
    // å®æ•°å’Œå¤æ•°çš„ç²¾åº¦å–å†³äºå®ƒä»¬çš„ç±»å‹ï¼Œå®æ•°çš„ç²¾åº¦æ˜¯ 32 ä½ï¼Œè€Œå¤æ•°çš„ç²¾åº¦æ˜¯ 64 ä½ã€‚

    // ç±»å‹è½¬æ¢å¿…é¡»æ˜¯æ˜¾å¼çš„. Rust æ°¸è¿œä¹Ÿä¸ä¼šå·å·æŠŠä½ çš„ 16bit æ•´æ•°è½¬æ¢æˆ 32bit æ•´æ•°ï¼Œå› ä¸ºè¿™æ ·åšä¼šå¯¼è‡´ç²¾åº¦ä¸¢å¤±ã€‚
}

use num::Complex;

fn complex_num() {
    let a = Complex { re: 2.1, im: -1.2 };
    let b = Complex::new(11.1, 22.2);
    let result = a + b;
    println!("{} + {}i = {}", result.re, result.im, result);
}

fn char() {
    // å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹
    // å­—ç¬¦æ˜¯ä¸€ç§ç±»å‹ï¼Œå®ƒæ˜¯ä¸€ä¸ª Unicode å­—ç¬¦ï¼Œå®ƒçš„å€¼æ˜¯ä¸€ä¸ª 32 ä½çš„æ•´æ•°ã€‚
    // å­—ç¬¦å¯ä»¥æ˜¯è‹±æ–‡å­—æ¯ï¼Œä¸­æ–‡æ±‰å­—
    // å­—ç¬¦å¯ä»¥æ˜¯æ•°å­—ï¼Œä½†æ˜¯ä¸èƒ½æ˜¯æ•°å­—å­—ç¬¦
    // å­—ç¬¦å¯ä»¥æ˜¯æ ‡ç‚¹ç¬¦å·ï¼Œä½†æ˜¯ä¸èƒ½æ˜¯æ ‡ç‚¹ç¬¦å·å­—ç¬¦
    // å­—ç¬¦å¯ä»¥æ˜¯ç©ºæ ¼ï¼Œä½†æ˜¯ä¸èƒ½æ˜¯ç©ºæ ¼å­—ç¬¦
    let c = 'c';
    let d = '\u{20BB7}';
    let e = '\u{00A9}';
    let f = '\u{1F680}';
    let g = 'ä¸­';
    let h = 'ğŸ˜';
    let i = 'â„¤';
    // let j = &g;

    println!(
        "{} {} {} {} {} {} {} {} {} {}",
        c, d, e, f, g, h, i, c as u32, d as u32, e as u32
    );
    // println!("{}", j);
    println!(
        "å­—ç¬¦'ä¸­'å ç”¨äº† {} å­—èŠ‚çš„å†…å­˜å¤§å°",
        std::mem::size_of_val(&g)
    );

    // å¸ƒå°”å€¼(bool)
    // å¸ƒå°”å€¼æ˜¯ Rust ä¸­çš„ä¸€ä¸ªåŸºæœ¬ç±»å‹ï¼Œå®ƒåªæœ‰ä¸¤ä¸ªå€¼ï¼štrue å’Œ falseã€‚
    // å¸ƒå°”å€¼å¯ä»¥ç”¨æ¥è¡¨ç¤ºé€»è¾‘å€¼ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºçŠ¶æ€å€¼ã€‚
    // å¸ƒå°”å€¼å¯ä»¥ç”¨æ¥è¡¨ç¤ºç©ºå€¼ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºéç©ºå€¼ã€‚
    // å¸ƒå°”å€¼å¯ä»¥ç”¨æ¥è¡¨ç¤ºé”™è¯¯å€¼ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºéé”™è¯¯å€¼ã€‚
    // å¸ƒå°”å€¼å¯ä»¥ç”¨æ¥è¡¨ç¤ºå¯å˜æ€§ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºéå¯å˜æ€§ã€‚
    // å¸ƒå°”å€¼å¯ä»¥ç”¨æ¥è¡¨ç¤ºå¯ç©ºæ€§ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºéå¯ç©ºæ€§ã€‚
    // å¸ƒå°”å€¼å¯ä»¥ç”¨æ¥è¡¨ç¤ºå¯è¾¾æ€§ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºéå¯è¾¾æ€§ã€‚
    let t = true;
    let f: bool = false; // ä½¿ç”¨ç±»å‹æ ‡æ³¨ï¼Œæ˜¾å¼æŒ‡å®šç±»å‹
    if t && f {
        println!("è¿™æ˜¯æ®µæ¯«æ— æ„ä¹‰çš„ä»£ç ")
    }

    // å•å…ƒç±»å‹å°±æ˜¯ () ï¼Œå”¯ä¸€çš„å€¼ä¹Ÿæ˜¯ () ï¼Œå®ƒæ˜¯ä¸€ä¸ªç©ºå…ƒç»„ã€‚
    // å¯ä»¥ä½œä¸ºmapçš„value
    // å¯ä»¥ä½œä¸ºä¸€ä¸ªå€¼ç”¨æ¥å ä½ï¼Œä½†æ˜¯å®Œå…¨ä¸å ç”¨ä»»ä½•å†…å­˜
}

// å‡½æ•°è¡¨è¾¾å¼æ˜¯ä¸€ç§ç‰¹æ®Šçš„å‡½æ•°ï¼Œå®ƒçš„ç±»å‹æ˜¯å®ƒè¢«è°ƒç”¨æ—¶æ‰€è¿”å›çš„ç±»å‹ã€‚
// å‡½æ•°è¡¨è¾¾å¼å¯ä»¥ç”¨æ¥åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥è°ƒç”¨ä¸€ä¸ªå‡½æ•°ã€‚
// mainå‡½æ•°æ˜¯ä¸€ä¸ªå‡½æ•°è¡¨è¾¾å¼ï¼Œå®ƒçš„ç±»å‹æ˜¯()->()ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒè¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ²¡æœ‰å‚æ•°ï¼Œè¿”å›å€¼ä¹Ÿæ˜¯()ã€‚
// è¡¨è¾¾å¼ä¸èƒ½åŒ…å«åˆ†å·ï¼Œä¸€æ—¦åœ¨è¡¨è¾¾å¼ååŠ ä¸Šåˆ†å·ï¼Œå®ƒå°±ä¼šå˜æˆä¸€æ¡è¯­å¥ï¼Œå†ä¹Ÿä¸ä¼šè¿”å›ä¸€ä¸ªå€¼
fn expression_fuc() {
    (|x: i32, y: i32| x + y)(1, 2);
    #[allow(unused_variables)]
    let a = 8;
    let b: Vec<f64> = Vec::new();
    let (a, c) = ("hi", false);
    println!("{} {:?} {}", a, b, c);
    let expr = add_with_extra(10, 20);
    println!("{}", expr);

    let x = plus_or_substract(10);
    println!("{}", x);
    let x = plus_or_minus(10, 20);
    println!("{}", x);
    report(10);
    // dead_end();
    ownership();
}

// å‡½æ•°åå’Œå˜é‡åä½¿ç”¨è›‡å½¢å‘½åæ³•(snake case)ï¼Œä¾‹å¦‚ fn add_two() -> {}
// å‡½æ•°çš„ä½ç½®å¯ä»¥éšä¾¿æ”¾ï¼ŒRust ä¸å…³å¿ƒæˆ‘ä»¬åœ¨å“ªé‡Œå®šä¹‰äº†å‡½æ•°ï¼Œåªè¦æœ‰å®šä¹‰å³å¯
// æ¯ä¸ªå‡½æ•°å‚æ•°éƒ½éœ€è¦æ ‡æ³¨ç±»å‹
// Rust çš„å‡½æ•°ä½“æ˜¯ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œæœ€åç”±ä¸€ä¸ªè¡¨è¾¾å¼æ¥è¿”å›å€¼ï¼Œä¾‹å¦‚ï¼š
fn add_with_extra(x: i32, y: i32) -> i32 {
    // è¯­å¥ä¼šæ‰§è¡Œä¸€äº›æ“ä½œä½†æ˜¯ä¸ä¼šè¿”å›ä¸€ä¸ªå€¼ï¼Œè€Œè¡¨è¾¾å¼ä¼šåœ¨æ±‚å€¼åè¿”å›ä¸€ä¸ªå€¼
    let x = x + 1; // è¯­å¥
    let y = y + 5; // è¯­å¥
    x + y // è¡¨è¾¾å¼
}

fn plus_or_substract(x: i32) -> i32 {
    if x > 5 {
        return x - 5;
    }
    x + 5
}
fn plus_or_minus(x: i32, y: i32) -> i32 {
    if x > y {
        x - y
    } else {
        x + y
    }
}
// å•å…ƒç±»å‹ ()ï¼Œæ˜¯ä¸€ä¸ªé›¶é•¿åº¦çš„å…ƒç»„ã€‚å®ƒæ²¡å•¥ä½œç”¨ï¼Œä½†æ˜¯å¯ä»¥ç”¨æ¥è¡¨è¾¾ä¸€ä¸ªå‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼š
// å‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆéšå¼è¿”å›ä¸€ä¸ª ()
// é€šè¿‡ ; ç»“å°¾çš„è¡¨è¾¾å¼è¿”å›ä¸€ä¸ª ()

use std::fmt::Debug;
// use std::fmt::Display;

// let x = (let y = 5);
fn report<T: Debug>(item: T) {
    println!("{:?}", item);
}
#[allow(dead_code)]
// æ˜¾å¼çš„è¿”å›äº† ()
fn clear(text: &mut String) -> () {
    // text.clear();
    // text
    // å°†æ–‡æœ¬å¤„çš„å­—ç¬¦ä¸²æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²
    *text = String::from("");
}
// æ°¸ä¸è¿”å›çš„å‡½æ•°!
// å½“ç”¨ `!` ä½œå‡½æ•°è¿”å›å€¼çš„æ—¶å€™ï¼Œè¡¨ç¤ºè¯¥å‡½æ•°æ°¸ä¸è¿”å›ï¼Œç‰¹åˆ«çš„ï¼Œè¿™ç§è¯­æ³•å¾€å¾€ç”¨åšä¼šå¯¼è‡´ç¨‹åºå´©æºƒçš„å‡½æ•°ï¼š
#[allow(dead_code)]
fn dead_end() -> ! {
    panic!("ä½ å·²ç»åˆ°äº†ç©·é€”æœ«è·¯ï¼Œå´©æºƒå§ï¼");
}
// ä¸‹é¢çš„å‡½æ•°åˆ›å»ºäº†ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œè¯¥å¾ªç¯æ°¸ä¸è·³å‡ºï¼Œå› æ­¤å‡½æ•°ä¹Ÿæ°¸ä¸è¿”å›ï¼š
#[allow(dead_code)]
fn forever() -> ! {
    loop {
        //...
    }
}

// Rust ä¸­çš„å‡½æ•°å¯ä»¥æœ‰å¯å˜å‚æ•°ï¼Œå¯å˜å‚æ•°æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„ç±»å‹æ˜¯ [T]ï¼Œå…¶ä¸­ T æ˜¯å¯å˜çš„ï¼Œ
// å¯å˜å‚æ•°åœ¨å‡½æ•°è°ƒç”¨æ—¶ä¼šè¢«è½¬æ¢æˆä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„é•¿åº¦æ˜¯å¯å˜å‚æ•°çš„ä¸ªæ•°ï¼Œæ•°ç»„çš„å…ƒç´ æ˜¯å¯å˜å‚æ•°çš„å€¼ã€‚
// å¯å˜å‚æ•°çš„ä¸ªæ•°å¯ä»¥æ˜¯ 0 ä¸ªï¼Œä¹Ÿå¯ä»¥æ˜¯ä»»æ„å¤šä¸ªã€‚
// å¯å˜å‚æ•°çš„ç±»å‹å¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œä½†æ˜¯ Rust ä¸­çš„æ‰€æœ‰ç±»å‹éƒ½æ˜¯å¯å˜çš„
// Rustæä¾›äº†ä¸€ä¸ªç‰¹æ®Šçš„å¯å˜å‚æ•°ï¼Œè¿™ä¸ªå¯å˜å‚æ•°æ˜¯ä¸€ä¸ª & æˆ–è€… &mut çš„å¼•ç”¨ï¼Œ
// å®ƒå¯ä»¥è®©å‡½æ•°æ¥å—ä¸€ä¸ªå¯å˜å‚æ•°çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯å¯å˜å‚æ•°çš„å€¼ã€‚
// å¯å˜å‚æ•°çš„å¼•ç”¨å¯ä»¥è¢«ä¼ é€’ç»™å‡½æ•°ï¼Œä½†æ˜¯ä¸èƒ½è¢«ä¿®æ”¹ï¼Œå› æ­¤å‡½æ•°ä¸èƒ½ä¿®æ”¹å‚æ•°çš„å€¼ã€‚
// Rust æä¾›åŠ¨æ€ç±»å‹ï¼Œè¿™æ„å‘³ç€å‡½æ•°å¯ä»¥æ¥å—ä»»æ„ç±»å‹çš„å‚æ•°ï¼Œè€Œä¸éœ€è¦æ˜¾å¼åœ°å£°æ˜å‚æ•°çš„ç±»å‹ã€‚
// Rust æä¾›äº†ä¸€ä¸ªç‰¹æ®Šçš„å‚æ•°ï¼Œè¿™ä¸ªå‚æ•°æ˜¯ä¸€ä¸ª &self çš„å¼•ç”¨ï¼Œå®ƒå¯ä»¥è®©å‡½æ•°æ¥å—ä¸€ä¸ªè‡ªèº«çš„å¼•ç”¨
// Rust æä¾›åŠ¨æ€å­—ç¬¦ä¸²ç±»å‹ï¼šStringï¼Œå®ƒæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¯å˜å¼•ç”¨ï¼Œå®ƒå¯ä»¥è¢«ä¼ é€’ç»™å‡½æ•°ï¼Œè¯¥ç±»å‹è¢«åˆ†é…åˆ°å †ä¸Šï¼Œå› æ­¤å¯ä»¥åŠ¨æ€ä¼¸ç¼©ï¼Œä¹Ÿå°±èƒ½å­˜å‚¨åœ¨ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥çš„æ–‡æœ¬
// å¯å˜å‚æ•°çš„å¼•ç”¨å¯ä»¥è¢«ä¼ é€’ç»™å‡½æ•°ï¼Œä½†æ˜¯ä¸èƒ½è¢«ä¿®æ”¹ï¼Œå› æ­¤å‡½æ•°ä¸èƒ½ä¿®æ”¹å‚æ•°çš„å€¼ã€‚
// åœ¨ Rust ä¸­ï¼Œå‡½æ•°å¯ä»¥æ¥å—ä¸€ä¸ªå¯å˜å‚æ•°çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯å¯å˜å‚æ•°çš„å€¼
// Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½ æœ‰ä¸”åªæœ‰ ä¸€ä¸ªæ‰€æœ‰è€…(å˜é‡)ï¼Œæ‰€æœ‰è€…æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡é’ˆæŒ‡å‘å€¼çš„å†…å­˜åœ°å€
// å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(free)ï¼Œå› æ­¤æ‰€æœ‰è€…(å˜é‡)ä¸èƒ½å†è¢«ä½¿ç”¨
// :: æ˜¯ä¸€ç§è°ƒç”¨æ“ä½œç¬¦
//  String ç±»å‹æ˜¯ä¸€ä¸ªå¤æ‚ç±»å‹ï¼Œç”±å­˜å‚¨åœ¨æ ˆä¸­çš„å †æŒ‡é’ˆã€å­—ç¬¦ä¸²é•¿åº¦ã€å­—ç¬¦ä¸²å®¹é‡å…±åŒç»„æˆï¼Œå…¶ä¸­å †æŒ‡é’ˆæ˜¯æœ€é‡è¦çš„ï¼Œå®ƒæŒ‡å‘äº†çœŸå®å­˜å‚¨å­—ç¬¦ä¸²å†…å®¹çš„å †å†…å­˜ï¼Œè‡³äºé•¿åº¦å’Œå®¹é‡ï¼Œåˆ™æ˜¯ç”±ç¼–è¯‘å™¨è‡ªåŠ¨è®¡ç®—çš„, å®¹é‡æ˜¯å †å†…å­˜åˆ†é…ç©ºé—´çš„å¤§å°ï¼Œé•¿åº¦æ˜¯ç›®å‰å·²ç»ä½¿ç”¨çš„å¤§å°, å½“é•¿åº¦å’Œå®¹é‡ç›¸ç­‰æ—¶ï¼Œå­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œå½“é•¿åº¦å¤§äºå®¹é‡æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ‰©å®¹ï¼Œæ‰©å®¹åçš„å®¹é‡æ˜¯åŸæ¥å®¹é‡çš„ä¸¤å€, å½“é•¿åº¦å°äºå®¹é‡æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç¼©å®¹ï¼Œç¼©å®¹åçš„å®¹é‡æ˜¯åŸæ¥å®¹é‡çš„ä¸€åŠ, æ€»ä¹‹ String ç±»å‹æŒ‡å‘äº†ä¸€ä¸ªå †ä¸Šçš„ç©ºé—´

//// Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½ æœ‰ä¸”åªæœ‰ ä¸€ä¸ªæ‰€æœ‰è€…(å˜é‡)
//// å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(free)
fn ownership() {
    let s = String::from("hello");
    // equals to `let s = "hello".to_string();`
    // s.push_str(" world");
    // sæ‰€æœ‰æƒè½¬ç§»åå¤±æ•ˆ
    let s3 = s; // s3 is a copy of s so s is no longer valid since it was moved
    let mut s2 = "hello".to_string();
    s2.push(char::from(65));
    // let mut s1 = s;
    // s1.push_str(" world"); // push_str() åœ¨å­—ç¬¦ä¸²åè¿½åŠ å­—é¢å€¼
    // println!("{}", s1);
    // println!("{}", s);
    println!("{}", s2);
    println!("{}", s3);
    // assert!(s3 == s);

    // Rust æ°¸è¿œä¹Ÿä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„ â€œæ·±æ‹·è´â€ å› æ­¤ï¼Œä»»ä½•è‡ªåŠ¨çš„å¤åˆ¶éƒ½ä¸æ˜¯æ·±æ‹·è´ï¼Œå¯ä»¥è¢«è®¤ä¸ºå¯¹è¿è¡Œæ—¶æ€§èƒ½å½±å“è¾ƒå°
    // å¦‚æœæˆ‘ä»¬ç¡®å®éœ€è¦æ·±åº¦å¤åˆ¶ String ä¸­å †ä¸Šçš„æ•°æ®ï¼Œè€Œä¸ä»…ä»…æ˜¯æ ˆä¸Šçš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå«åš clone çš„æ–¹æ³•ã€‚
    // åœ¨ Rust ä¸­ï¼Œæ‰€æœ‰çš„æ•°æ®ç±»å‹éƒ½æ˜¯å€¼ç±»å‹ï¼Œå€¼ç±»å‹çš„æ•°æ®åœ¨è¢«èµ‹å€¼æˆ–ä¼ é€’æ—¶ï¼Œä¼šè¢«å¤åˆ¶ï¼Œè€Œå¼•ç”¨ç±»å‹çš„æ•°æ®åœ¨è¢«èµ‹å€¼æˆ–ä¼ é€’æ—¶ï¼Œä¸ä¼šè¢«å¤åˆ¶ï¼Œè€Œæ˜¯è¢«å¼•ç”¨
    // å¯¹äºæ‰§è¡Œè¾ƒä¸ºé¢‘ç¹çš„ä»£ç (çƒ­ç‚¹è·¯å¾„)ï¼Œä½¿ç”¨ clone ä¼šæå¤§çš„é™ä½ç¨‹åºæ€§èƒ½ï¼Œéœ€è¦å°å¿ƒä½¿ç”¨ï¼

    let s4 = s3.clone();
    print!("{}", s4);

    // æµ…æ‹·è´åªå‘ç”Ÿåœ¨æ ˆä¸Šï¼Œå› æ­¤æ€§èƒ½å¾ˆé«˜ï¼Œåœ¨æ—¥å¸¸ç¼–ç¨‹ä¸­ï¼Œæµ…æ‹·è´æ— å¤„ä¸åœ¨ã€‚
    // é€šç”¨çš„è§„åˆ™ï¼šä»»ä½•åŸºæœ¬ç±»å‹çš„ç»„åˆå¯ä»¥æ˜¯ Copy çš„ï¼Œä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹æ˜¯ Copy çš„
    // å¯¹äºå¼•ç”¨ç±»å‹ï¼Œå¦‚æœå®ƒçš„æ‰€æœ‰è€…(å˜é‡)æ˜¯ Copy çš„ï¼Œé‚£ä¹ˆå®ƒä¹Ÿæ˜¯ Copy çš„
    // æ‰€æœ‰æ•´æ•°ç±»å‹ã€æ‰€æœ‰æµ®ç‚¹æ•°ç±»å‹ã€å¸ƒå°”ç±»å‹boolã€å­—ç¬¦ç±»å‹charã€æ‰€æœ‰æŒ‡é’ˆç±»å‹ã€æ‰€æœ‰å¼•ç”¨ç±»å‹ã€å…ƒç»„ï¼ˆå½“ä¸”ä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½æ˜¯ Copy çš„æ—¶å€™ï¼‰å’Œæ‰€æœ‰ç»“æ„ä½“ç±»å‹éƒ½æ˜¯ Copy çš„
    // å°†å€¼ä¼ é€’ç»™å‡½æ•°ï¼Œä¸€æ ·ä¼šå‘ç”Ÿ ç§»åŠ¨ æˆ–è€… å¤åˆ¶
    // å¦‚æœä½ æƒ³è¦åœ¨å‡½æ•°ä¸­ä¿®æ”¹å‚æ•°çš„å€¼ï¼Œä½ å¿…é¡»ä½¿ç”¨å¼•ç”¨ï¼Œè€Œä¸æ˜¯å€¼
    let x = 5;
    takes_ownership(s3); // s3 è¢«ç§»åŠ¨åˆ°å‡½æ•°å†…éƒ¨ï¼Œå› æ­¤ s3 ä¸å†æœ‰æ•ˆ
    makes_copy(x); // x è¢«å¤åˆ¶åˆ°å‡½æ•°å†…éƒ¨ï¼Œä½† x ä¾ç„¶æœ‰æ•ˆ

    // åŒæ ·çš„ï¼Œå‡½æ•°è¿”å›å€¼ä¹Ÿæœ‰æ‰€æœ‰æƒ
    let s5 = gives_ownership(); // gives_ownership å‡½æ•°è¿”å›å€¼è¢«ç§»åŠ¨åˆ° s5 ä¸­
    let s6 = String::from("hello"); // s6 è¢«å¤åˆ¶åˆ°å‡½æ•°å†…éƒ¨ï¼Œä½† s6 ä¾ç„¶æœ‰æ•ˆ
    let s7 = takes_and_gives_back(s6); // s6 è¢«ç§»åŠ¨åˆ°å‡½æ•°å†…éƒ¨ï¼Œå®ƒå°†è¿”å›å€¼èµ‹å€¼ç»™ s7
    println!("{} {}", s5, s7);

    // æ‰€æœ‰æƒå¾ˆå¼ºå¤§ï¼Œé¿å…äº†å†…å­˜çš„ä¸å®‰å…¨æ€§ï¼Œä½†æ˜¯ä¹Ÿå¸¦æ¥äº†ä¸€ä¸ªæ–°éº»çƒ¦:æ€»æ˜¯æŠŠä¸€ä¸ªå€¼ä¼ æ¥ä¼ å»æ¥ä½¿ç”¨å®ƒã€‚ ä¼ å…¥ä¸€ä¸ªå‡½æ•°ï¼Œå¾ˆå¯èƒ½è¿˜è¦ä»è¯¥å‡½æ•°ä¼ å‡ºå»ï¼Œç»“æœå°±æ˜¯è¯­è¨€è¡¨è¾¾å˜å¾—éå¸¸å•°å—¦ï¼Œå¹¸è¿çš„æ˜¯ï¼ŒRust æä¾›äº†æ–°åŠŸèƒ½è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
} // s5,s6, s7 ä½œç”¨åŸŸç»“æŸåç§»é™¤ï¼Œå¹¶ä¸”æ¸…ç†s5, s7ä¸­çš„å†…å­˜, s6è¢«ç§»å…¥å‡½æ•°ä¸­

fn gives_ownership() -> String {
    let some_string = String::from("hello"); // some_string è¢«ç§»åŠ¨åˆ°å‡½æ•°å†…éƒ¨
    some_string // some_string è¿”å›ç»™è°ƒç”¨å‡½æ•°å¹¶ä¸”è¢«ç§»åŠ¨åˆ°å‡½æ•°å¤–éƒ¨
}
// å‡½æ•°ä¼ é€’ç»™å¦ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œå‡½æ•°å†…éƒ¨çš„å˜é‡ä¼šè¢«ç§»åŠ¨åˆ°å‡½æ•°å¤–éƒ¨ï¼Œè€Œä¸æ˜¯è¢«å¤åˆ¶
// åœ¨å‡½æ•°å†…éƒ¨ï¼Œå˜é‡çš„ç”Ÿå‘½å‘¨æœŸä»…é™äºå‡½æ•°å†…éƒ¨ï¼Œå‡½æ•°ç»“æŸåï¼Œå˜é‡çš„ç”Ÿå‘½å‘¨æœŸå°±ç»“æŸäº†
// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²ç§»åŠ¨åˆ°å‡½æ•°å†…éƒ¨å¹¶è¿”å›
fn takes_and_gives_back(a_string: String) -> String {
    a_string // a_string è¢«ç§»åŠ¨åˆ°å‡½æ•°å¤–éƒ¨å¹¶è¿”å›
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // ä½œç”¨åŸŸç»“æŸï¼Œsome_string è¢«ä¸¢å¼ƒå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
} // ä½œç”¨åŸŸç»“æŸï¼Œsome_integer ä¾ç„¶æœ‰æ•ˆ

// å¼•ç”¨ä¸è§£å¼•ç”¨
// å¼•ç”¨æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæŒ‡å‘ä¸€ä¸ªå˜é‡çš„å†…å­˜åœ°å€ï¼Œè€Œä¸æ˜¯å˜é‡æœ¬èº«ã€‚
// å¼•ç”¨çš„ä½œç”¨æ˜¯è®©å‡½æ•°èƒ½å¤Ÿè®¿é—®å˜é‡çš„å†…å®¹ï¼Œè€Œä¸èƒ½æ”¹å˜å˜é‡çš„å†…å®¹ã€‚
// å¼•ç”¨çš„ç±»å‹æ˜¯ &Tï¼Œå…¶ä¸­ T æ˜¯å˜é‡çš„ç±»å‹ã€‚
// å¼•ç”¨çš„ä½œç”¨åŸŸæ˜¯åœ¨å‡½æ•°å†…éƒ¨ï¼Œdrop å‡½æ•°ä¸ä¼šè¢«è°ƒç”¨, å› æ­¤å¼•ç”¨çš„å˜é‡ä¸ä¼šè¢«é‡Šæ”¾
// å¼•ç”¨æ²¡æœ‰æ‰€æœ‰æƒï¼Œæ‰€ä»¥å®ƒä¸èƒ½è¢«ç§»åŠ¨ï¼Œä½†æ˜¯å®ƒå¯ä»¥è¢«å¤åˆ¶
// å¼•ç”¨çš„ä½œç”¨åŸŸç»“æŸåï¼Œå¼•ç”¨æ‰€æŒ‡å‘çš„å˜é‡çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿç»“æŸäº†ã€‚
// å¯å˜å¼•ç”¨åŒæ—¶å…·æœ‰æ‰€æœ‰æƒå’Œå¯å˜æ€§ï¼Œæ‰€ä»¥å®ƒä»¬å¯ä»¥è¢«ç§»åŠ¨ï¼Œä½†æ˜¯å®ƒä»¬ä¸èƒ½è¢«å¤åˆ¶
// å¯å˜å¼•ç”¨çš„ç±»å‹æ˜¯ &mut Tï¼Œå…¶ä¸­ T æ˜¯å˜é‡çš„ç±»å‹ã€‚
// å¯å˜å¼•ç”¨åŒæ—¶åªèƒ½å­˜åœ¨ä¸€ä¸ªï¼Œå› æ­¤å®ƒä»¬ä¸èƒ½è¢«å¤åˆ¶
// åŒä¸€ä½œç”¨åŸŸï¼Œç‰¹å®šæ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨
// è¿™ç§é™åˆ¶çš„å¥½å¤„å°±æ˜¯ä½¿ Rust åœ¨ç¼–è¯‘æœŸå°±é¿å…æ•°æ®ç«äº‰ï¼Œæ•°æ®ç«äº‰å¯ç”±ä»¥ä¸‹è¡Œä¸ºé€ æˆï¼š
// ä¸¤ä¸ªæˆ–æ›´å¤šçš„æŒ‡é’ˆåŒæ—¶è®¿é—®åŒä¸€æ•°æ®
// è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆè¢«ç”¨æ¥å†™å…¥æ•°æ®
// æ²¡æœ‰åŒæ­¥æ•°æ®è®¿é—®çš„æœºåˆ¶
// æ•°æ®ç«äº‰ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼Œè¿™ç§è¡Œä¸ºå¾ˆå¯èƒ½è¶…å‡ºæˆ‘ä»¬çš„é¢„æœŸï¼Œéš¾ä»¥åœ¨è¿è¡Œæ—¶è¿½è¸ªï¼Œå¹¶ä¸”éš¾ä»¥è¯Šæ–­å’Œä¿®å¤ã€‚è€Œ Rust é¿å…äº†è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œå› ä¸ºå®ƒç”šè‡³ä¸ä¼šç¼–è¯‘å­˜åœ¨æ•°æ®ç«äº‰çš„ä»£ç ï¼
use std::ops::Deref;
fn renference_and_dereference() {
    let x = 5;
    let y = &x; // y æ˜¯ x çš„å¼•ç”¨
    println!("x = {}, y = {},", x, y);
    assert_eq!(5, x);
    assert_eq!(5, *y); // å–å¼•ç”¨çš„å€¼

    assert_eq!(5, *y.deref());
    // assert_eq!(5, y.deref());
    // assert_eq!(5, y); // error:æ— æ³•æ¯”è¾ƒæ•´æ•°ç±»å‹å’Œå¼•ç”¨ç±»å‹

    // TODO cannot borrow `x` as mutable, as it is not declared as mutable
    // let z = &mut x; // z æ˜¯ x çš„å¼•ç”¨
    // println!("x = {}, z = {}", x, z);

    // ä¸å¯å˜å¼•ç”¨ `&s` æ— æ³•ä¿®æ”¹å¼•ç”¨æ‰€æŒ‡å‘çš„å˜é‡çš„å€¼
    let s = String::from("hello");
    let len = calculate_length(&s);
    println!("The length of '{}' is {}.", s, len);

    // å¯å˜å¼•ç”¨ `&mut s` å¯ä»¥ä¿®æ”¹å¼•ç”¨æ‰€æŒ‡å‘çš„å˜é‡çš„å€¼
    let mut s = String::from("hello");
    let _s = change(&mut s);
    println!("{}", s);

    {
        let r1 = &mut s;
        println!("{}", r1);
    } // r1 åœ¨è¿™é‡Œç¦»å¼€äº†ä½œç”¨åŸŸï¼Œæ‰€ä»¥æˆ‘ä»¬å®Œå…¨å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„å¼•ç”¨

    let r2 = &mut s;
    println!("{}", r2);

    // å¯å˜å¼•ç”¨ä¸ä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨
    // å¯å˜å¼•ç”¨å¿…é¡»è¢«åˆå§‹åŒ–ï¼Œä¸å¯å˜å¼•ç”¨ä¸èƒ½è¢«åˆå§‹åŒ–
    // å…¶å®è¿™ä¸ªä¹Ÿå¾ˆå¥½ç†è§£ï¼Œæ­£åœ¨å€Ÿç”¨ä¸å¯å˜å¼•ç”¨çš„ç”¨æˆ·ï¼Œè‚¯å®šä¸å¸Œæœ›ä»–å€Ÿç”¨çš„ä¸œè¥¿ï¼Œè¢«å¦å¤–ä¸€ä¸ªäººè«åå…¶å¦™æ”¹å˜äº†ã€‚å¤šä¸ªä¸å¯å˜å€Ÿç”¨è¢«å…è®¸æ˜¯å› ä¸ºæ²¡æœ‰äººä¼šå»è¯•å›¾ä¿®æ”¹æ•°æ®ï¼Œæ¯ä¸ªäººéƒ½åªè¯»è¿™ä¸€ä»½æ•°æ®è€Œä¸åšä¿®æ”¹ï¼Œå› æ­¤ä¸ç”¨æ‹…å¿ƒæ•°æ®è¢«æ±¡æŸ“ã€‚
    let mut s = String::from("hello");

    // let r1 = &s; // æ²¡é—®é¢˜
    // let r2 = &s; // æ²¡é—®é¢˜
    // let r3 = &mut s; // å¤§é—®é¢˜, æ— æ³•å€Ÿç”¨å¯å˜ `s` å› ä¸ºå®ƒå·²ç»è¢«å€Ÿç”¨äº†ä¸å¯å˜å¼•ç”¨
    // println!("{}, {}, and {}", r1, r2, r3);

    // å¼•ç”¨çš„ä½œç”¨åŸŸ s ä»åˆ›å»ºå¼€å§‹ï¼Œä¸€ç›´æŒç»­åˆ°å®ƒæœ€åä¸€æ¬¡ä½¿ç”¨çš„åœ°æ–¹ï¼Œè¿™ä¸ªè·Ÿå˜é‡çš„ä½œç”¨åŸŸæœ‰æ‰€ä¸åŒï¼Œå˜é‡çš„ä½œç”¨åŸŸä»åˆ›å»ºæŒç»­åˆ°æŸä¸€ä¸ªèŠ±æ‹¬å· }
    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // æ–°ç¼–è¯‘å™¨ä¸­ï¼Œr1,r2ä½œç”¨åŸŸåœ¨è¿™é‡Œç»“æŸ

    let r3 = &mut s;
    println!("{}", r3);

    dangling_reference();
}
// æ‚¬å‚å¼•ç”¨ï¼ˆDangling Referencesï¼‰
// æ‚¬å‚å¼•ç”¨ä¹Ÿå«åšæ‚¬å‚æŒ‡é’ˆï¼Œæ„æ€ä¸ºæŒ‡é’ˆæŒ‡å‘æŸä¸ªå€¼åï¼Œè¿™ä¸ªå€¼è¢«é‡Šæ”¾æ‰äº†ï¼Œè€ŒæŒ‡é’ˆä»ç„¶å­˜åœ¨ï¼Œå…¶æŒ‡å‘çš„å†…å­˜å¯èƒ½ä¸å­˜åœ¨ä»»ä½•å€¼æˆ–å·²è¢«å…¶å®ƒå˜é‡é‡æ–°ä½¿ç”¨ã€‚åœ¨ Rust ä¸­ç¼–è¯‘å™¨å¯ä»¥ç¡®ä¿å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šå˜æˆæ‚¬å‚çŠ¶æ€ï¼šå½“ä½ æ‹¥æœ‰ä¸€äº›æ•°æ®çš„å¼•ç”¨ï¼Œç¼–è¯‘å™¨å¯ä»¥ç¡®ä¿æ•°æ®ä¸ä¼šåœ¨å…¶å¼•ç”¨ä¹‹å‰è¢«é‡Šæ”¾ï¼Œè¦æƒ³é‡Šæ”¾æ•°æ®ï¼Œå¿…é¡»å…ˆåœæ­¢å…¶å¼•ç”¨çš„ä½¿ç”¨ã€‚
fn dangling_reference() {
    // dangle ä¸èƒ½è¿”å›æ‚¬å‚å¼•ç”¨&str
    let reference_to_nothing = dangle();
    println!("{}", reference_to_nothing);
}
// fn dangle() -> &String {
//     let s = String::from("hello");
//     // &s
// } // è¿™é‡Œ s ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚å…¶å†…å­˜è¢«é‡Šæ”¾, å› æ­¤&så¼•ç”¨æŒ‡å‘ä¸€ä¸ªæ— æ•ˆçš„å€¼

// Stringçš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™å¤–é¢çš„è°ƒç”¨è€…ã€‚
fn dangle() -> String {
    let s = String::from("hello");
    s // è¿”å›å€¼ s è¢«è½¬ç§»ç»™äº†å‡½æ•°è°ƒç”¨è€…ï¼Œs ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ,æ‰€ä»¥ä¸èƒ½è¿”å›&s, å› ä¸º&sæŒ‡å‘çš„å†…å­˜å·²ç»è¢«é‡Šæ”¾,å¦åˆ™ä¼šæˆä¸ºæ‚¬å‚å¼•ç”¨
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

fn change(some_string: &mut String) -> &String {
    some_string.push_str(", world");
    some_string
}
// fn change(some_string: &mut String) {
//     some_string.push_str(", world");
// }

// fn mix_up(a: &str, b: &str) -> String {
//     let mut result = String::new();
//     result.push_str(b);
//     result.push_str(a);
//     result
// }

// å¤åˆç±»å‹
// å¤åˆç±»å‹æ˜¯ä¸€ç§ç±»å‹ï¼Œå®ƒå¯ä»¥æ˜¯å…¶ä»–ç±»å‹çš„å­é›†ã€‚
// åœ¨ Rust ä¸­ï¼Œå¤åˆç±»å‹æ˜¯é€šè¿‡å…ƒç»„ï¼ˆtupleï¼‰æ¥å®ç°çš„ï¼Œå…ƒç»„æ˜¯ä¸€ç§å¤åˆç±»å‹ã€‚
// å…ƒç»„å¯ä»¥åŒ…å«ä¸åŒç±»å‹çš„å€¼ï¼Œå¹¶ä¸”æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªåå­—ã€‚
// å…ƒç»„çš„ç±»å‹æ˜¯ç”±å…¶ä¸­çš„æ¯ä¸ªå€¼çš„ç±»å‹ç»„æˆçš„ã€‚

fn compound_types() {
    let tuple = (1, 2, 3);
    let (x, y, z) = tuple;
    println!("{}, {}, {}", x, y, z);

    let tuple2 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    let (a, b, c, d, e, f, g, h, i, j) = tuple2;
    println!(
        "{}, {}, {}, {}, {}, {}, {}, {}, {}, {}",
        a, b, c, d, e, f, g, h, i, j
    );
    file_operations();

    // structs();
    // enums();
    // å­—ç¬¦ä¸²String ä¸ åˆ‡ç‰‡ &str
    let n = 120;
    greater_than_100(n);

    // åˆ‡ç‰‡(slice)å¹¶ä¸æ˜¯ Rust ç‹¬æœ‰çš„æ¦‚å¿µ,å®ƒå…è®¸ä½ å¼•ç”¨é›†åˆä¸­éƒ¨åˆ†è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯å¼•ç”¨æ•´ä¸ªé›†åˆã€‚
    // å¯¹äºå­—ç¬¦ä¸²è€Œè¨€ï¼Œåˆ‡ç‰‡å°±æ˜¯å¯¹ String ç±»å‹ä¸­æŸä¸€éƒ¨åˆ†çš„å¼•ç”¨ï¼Œå®ƒçœ‹èµ·æ¥åƒè¿™æ ·
    // åˆ‡ç‰‡æ˜¯æè¿°ä¸€ç»„å±äºåŒä¸€ç±»å‹ã€é•¿åº¦ä¸ç¡®å®šçš„ã€åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾çš„æ•°æ®ç»“æ„ï¼Œç”¨ [T] æ¥è¡¨è¿°ã€‚å› ä¸ºé•¿åº¦ä¸ç¡®å®šï¼Œæ‰€ä»¥åˆ‡ç‰‡æ˜¯ä¸ª DSTï¼ˆDynamically Sized Typeï¼‰
    // åˆ‡ç‰‡çš„ç±»å‹æ˜¯ &[T]ï¼Œå…¶ä¸­ T æ˜¯åˆ‡ç‰‡æ‰€æŒ‡å‘çš„æ•°æ®ç±»å‹ã€‚
    // åˆ‡ç‰‡å› ä¸ºé•¿åº¦ä¸ç¡®å®šï¼Œå±äºunsizedç±»å‹ï¼Œä¸èƒ½ç›´æ¥è®¿é—®ï¼Œæ‰€ä»¥ä¸€èˆ¬é€šè¿‡&[T]ï¼Œ&mut[T]ï¼ŒBox<[T]>è¿™ä¸‰ç§å¼•ç”¨æ–¹å¼ä½¿ç”¨åˆ‡ç‰‡ã€‚
    // åˆ‡ç‰‡çš„ç±»å‹æ ‡è¯†ç¬¦ &[T] å’Œ &mut [T] å¯ä»¥ç”¨äºæŒ‡å‘ä»»ä½•ç±»å‹çš„æ•°ç»„ï¼Œè€Œ Box<[T]> åªèƒ½æŒ‡å‘æ•°ç»„ç±»å‹ã€‚
    // &str ç±»å‹ ä¸ &String ç±»å‹
    let s = String::from("Hello World");
    let s1 = "Jello".to_string();
    // let s: &str = "World";
    // let r = &s;
    // let all = &s[..];
    let hello = &s[0..5];
    // equals `let hello = &s[..5];`
    let world = &s[6..11];
    // equals `let world = &s[6..];` and `let world = &s[6..s.len()];`
    greet(s1);
    println!("{} {}", hello, world);

    let s = "ä¸­å›½äºº".to_string();
    // let s = "HELLO";
    let a = &s[0..3]; // åˆ‡ç‰‡çš„ç´¢å¼•å¿…é¡»è½åœ¨å­—ç¬¦ä¹‹é—´çš„è¾¹ç•Œä½ç½®, æ¯ä¸ªæ±‰å­—å ç”¨3ä¸ªå­—èŠ‚ï¼Œ&s[0..2] å°±ä¼šæŠ¥é”™
    println!("{} {}", a, s.len());
    greet(s);

    let mut s = String::from("hello world");
    // #[allow(unused_variables)]
    let word = first_word(&s);
    println!("this first word is {}", word); // println å¿…é¡»åœ¨clearä¹‹å‰
    s.clear(); //  clear(&mut self) æ–¹æ³•æ¸…ç©ºå­—ç¬¦ä¸²,æ­¤å¤„å¯å˜å¼•ç”¨å°è¯•è°ƒç”¨clearæ–¹æ³•

    // å­—ç¬¦ä¸²çš„åˆ‡ç‰‡ç±»å‹æ˜¯ &strï¼Œè€Œä¸æ˜¯ &Stringã€‚ æ•°ç»„çš„åˆ‡ç‰‡ç±»å‹æ˜¯ &[T]ï¼Œè€Œä¸æ˜¯ &Vec<T>ã€‚
    // å› ä¸ºåˆ‡ç‰‡æ˜¯å¯¹é›†åˆçš„éƒ¨åˆ†å¼•ç”¨ï¼Œå› æ­¤ä¸ä»…ä»…å­—ç¬¦ä¸²æœ‰åˆ‡ç‰‡ï¼Œå…¶å®ƒé›†åˆç±»å‹ä¹Ÿæœ‰ï¼Œä¾‹å¦‚æ•°ç»„ï¼š
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3]; // è¯¥æ•°ç»„åˆ‡ç‰‡çš„ç±»å‹æ˜¯ `&[i32]`
    println!("{:?}", slice);
    assert_eq!(slice, &[2, 3]);

    // æœ€å…¸å‹çš„å°±æ˜¯ç»“æ„ä½“ struct å’Œæšä¸¾ enum
    // #[derive(Debug)]
    // struct Color(i32, i32, i32);
}
//
fn first_word(s: &String) -> &str {
    // s[..s.find(' ').unwrap_or(s.len())].trim()
    &s[..1]
}

// fn first_word(s &String) -> String {
//     let bytes = s.as_bytes();
//     for (i, &item) in bytes.iter().enumerate() {
//         if item == b' ' {
//             return s[0..i].to_string();
//         }
//     }
//     s.to_string()
// }

// fn first_word(s: &String) -> usize {
//     let bytes = s.as_bytes();
//     for (i, &item) in bytes.iter().enumerate() {
//         if item == b' ' {
//             return i;
//         }
//     }
//     s.len()
// }
fn greet(name: String) {
    println!("Hello, {}!", name);
}
fn greater_than_100(n: i32) -> bool {
    n > 100
}

// file operations
fn file_operations() {
    #![allow(unused_variables)]
    type File = String;
    fn open(f: &mut File) -> bool {
        true
    }
    fn close(f: &mut File) -> bool {
        true
    }
    #[allow(dead_code)]
    fn read(f: &mut File, save_to: &mut Vec<u8>) -> ! {
        // panic!("not implemented");
        // è¿™é‡Œçš„ ! æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°ä¸ä¼šè¿”å›ä»»ä½•å€¼ï¼ŒåŒ…æ‹¬ ()ï¼Œè€Œæ˜¯ç›´æ¥ç»ˆæ­¢è¿è¡Œã€‚
        // read æ˜¯ä¸€ä¸ªå‘æ•£å‡½æ•°ï¼Œå› æ­¤å®ƒçš„è¿”å›å€¼ç±»å‹æ˜¯ !ã€‚
        // è¿™æ„å‘³ç€å®ƒçš„è¿”å›å€¼ç±»å‹æ˜¯ä¸ç¡®å®šçš„ï¼Œå› ä¸ºå®ƒå¯èƒ½ä¼šåœ¨è¿è¡Œæ—¶å‘ç”Ÿé”™è¯¯ã€‚
        // unimplemented!() å‘Šè¯‰ç¼–è¯‘å™¨è¯¥å‡½æ•°å°šæœªå®ç°ï¼Œå¹¶ä¸”ç¼–è¯‘å™¨ä¼šç»ˆæ­¢ç¨‹åºè¿è¡Œã€‚
        // ç±»ä¼¼çš„æ ‡è®°è¿˜æœ‰ todo!() å’Œ unreachable!()ã€‚
        unimplemented!()
    }

    let mut f1 = File::from("file1.txt");
    open(&mut f1);
    // read(&mut f1, &mut Vec::new());
    // read(&mut f1, &mut Vec![0; 10]);
    // read(&mut f1, &mut vec![]);
    close(&mut f1);
    // let file = File::from("hello.txt");
    // fn open(f: &mut File) -> Result<(), &str> {
    //     // ...
    //     Ok(())
    // }
    // fn open(filename: File) -> Result<File, String> {
    //     Ok(filename)
    // }
}
// fn file_struct() {
//     #[derive(Debug)]
//     struct File {
//         name: String,
//         size: u64,
//     }
//     impl File {
//         fn new(name: String, size: u64) -> File {
//             File { name, size }
//         }
//     }
//     let file = File::new(String::from("hello.txt"), 100);
//     println!("{:?}", file);
// }

fn test() {
    #[allow(unused_assignments)]
    let mut aa = 10;
    aa = 2021;
    #[allow(unused_assignments)]
    let mut bb = aa;
    bb = 2022;
    println!("aa = {} bb = {}", aa, bb);
}
